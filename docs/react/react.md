---
title: "React"
nav_exclude: true
---



# Компоненты

## Компоненты и данные

### Хранение данных компонента

- [ ] Состояние
  - [ ] Это данные, изменение которых приводит к ре-рендеру компонента.
    - [ ] useState
      - [ ] Инициализация
        - [ ] Значением
        - [ ] Функция, вычисляющая и в возвращающая значение
      - [ ] Изменение
        - [ ] Перезаписать состояние
        - [ ] Вычислить новое состояние на основе предыдущего
    - [ ] useReducer
  - [ ] Принципы хранения состояния
    - [ ] Иммутабельность - заменяй, а не изменяй
      - [ ] Библиотека Immer
  - [ ] Механика изменения состояния
    - [ ] Изменение через хук > Запрос на фактическое изменение > Фактическое изменение > Ре-рендеринг
  - [ ] Место хранения состояния
    - [ ] В одном компоненте может быть много состояний
    - [ ] Эти состояния хранятся как список в fiber-узле
- [ ] Данные, изменение которых не приводит к ре-рендеру компонента
  - [ ] useRef
  - [ ] Можем мутировать эти данные.

### Передача данных в компоненты

- [ ] Направление передачи данных
  - [ ] "Сверху вниз" - из родителя в дочерний компонент
    - [ ] Пропсы
      - [ ] Стандартные пропсы (children)
      - [ ] Наши произвольные пропсы
      - [ ] Проброс пропсов в дочерний компонент {...props}
  - [ ] "Снизу вверх" - из дочернего компонента в родительский
    - [ ] Через колбэк
- [ ] Передача данных в глубоко вложенные дочерние компоненты (useContext)
  - [ ] Контекст, провайдер контекста
  - [ ] Использование нескольких контекстов (вложение контекстов друг в друга)
  - [ ] Обновление значения в контексте

## Вид компонента

- [ ] По синтаксису создания
  - [ ] Функциональный компонент (современно, с хуками)
  - [ ] Классовый компонент (легаси)
- [ ] По управлению данными компонента
  - [ ] Управляемый компонент (полная синхронизация данных из элементов с состоянием компонента)
  - [ ] Неуправляемый компонент (нет синхронизации, ручное получение значений когда надо через ссылки на элементы)
    - [ ] Атрибут ref у компонента
    - [ ] Сохранение ссылки на реальный DOM-элемент (ref + useRef)
    - [ ] Проброс ref в самописный компонент с помощью функции React.forwardRef

## Жизненный цикл компонента

- [ ] Этапы жизненного цикла компонента
  - [ ] Монтирование
  - [ ] Рендеринг (первичный и ре-рендеринг)
  - [ ] Размонтирование
- [ ] Выполнить функцию на желаемом этапе жизненного цикла (useEffect)
  - [ ] Для разных целей, например
    - [ ] Предварительная загрузка данных для отображения.
    - [ ] Различные действия по очистке (отписка от событий)
    - [ ] И т.д.

## Уникальность компонента

- [ ] Зачем реакту различать компоненты
- [ ] Уникальность однотипных компонентов в списках, свойство key
- [ ] Уникальность по позиции в fiber-дереве и по типу компонента

## Оформление компонента

- [ ] Правила именования компонентов.
- [ ] Использование css-стилей в компоненте.



# JSX

- [ ] Преобразование JSX в html (React.createElement)
- [ ] Использование выражений в JSX { }



# Оптимизации

## Кэширование (мемоизация)

- [ ] "Тактическая оптимизация"
- [ ] Кэширование внутри компонента
  - [ ] Кэширование функции (useCallback)
  - [ ] Кэширование результата выполнения функции (useMemo)
  - [ ] Массив зависимостей
- [ ] Кэширование целого компонента
  - [ ] React.memo - "пропсы компонента меняются редко - кэшируй этот компонент"
    - [ ] Кастомный компаратор - сами пишем функцию сравнения пропсов
  - [ ] Пример: большой список элементов, один изменился - остальные нет, кэширование элемента списка полезно.

## Ленивая загрузка

- [ ] Основной бандл и чанки
  - [ ] По умолчанию все модули собираются в единый бандл
  - [ ] Если сборщик видит динамический import компонента - выделяет компонент в отдельный чанк
    - [ ] С помощью хинтов можно группировать несколько модулей в один чанк. Хинты специфичны для каждого сборщика, универсального подхода нет
- [ ] Ленивый компонент ErrorBoundary > Suspense + fallback > React.lazy + import()
- [ ] Предзагрузка
  - [ ] Вызов import() при наведении мышки на ссылку / при появлении ссылки во вьюпорте
  - [ ] Если чанк успеет загрузиться, ленивый компонент покажется без fallback'а

## Code splitting

- [ ] "Стратегическая оптимизация"
- [ ] Основные 4 стратегии разделения кода
  - [ ] Маршруты (разные страницы - в отдельных чанках)
  - [ ] Компоненты (табы, модальные окна, виджеты)
  - [ ] Библиотеки (react + react dom + lodash = vendor чанк, main + home = чанк нашего приложения)
  - [ ] Условия (авторизованные \ неавторизованные пользователи \ по роли пользователя)
- [ ] Плюсы
  - [ ] Параллельная загрузка нескольких чанков быстрее, чем загрузка одного большого бандла
  - [ ] Кэширование чанка. Сам react + остальные библиотеки при обновлениях логики приложения не менялись => браузер может его закешировать, а загрузить только наши изменившиеся чанки
  - [ ] CDN - можно вообще не вносить либы в бандл, а подключать через CDN. Если пользователь пользовался другим приложением, которому нужны были такие же либы, то они у него уже закэшированы.

# Типичные трюки \ паттерны

## Условный рендеринг

- [ ] Показать \ не показать компонент в зависимости от условия ( && )
- [ ] Показать разные компоненты в зависимости от условия ( тернарный оператор )

## HOC + Render Props + Custom Hooks

### HOC

- [ ] HOC - Higher-Order Component.
  - [ ] Это паттерн, цель которого - "обвязать" исходный компонент дополнительной функциональностью.
    - [ ] "Сквозная функциональность": логирование \ телеметрия \ кэширование \ авторизация \ etc
    - [ ] "Множественные дефолты" - снабдить исходный компонент каким-то фиксированным значением для определенных пропсов. Несколько HOC-ов, каждый со своим дефолтом = несколько вариантов пред-конфигурированного компонента
- [ ] HOC - это функция, которая принимает исходный компонент и возвращает компонент-обертку, который внутри использует исходный.
  - [ ] Пример на обычных функциях: исходная функция - расчет числа

### Render Props

- [ ] Основная идея - Компонент-провайдер + Компонент Клиент
  - [ ] Провайдер реализует какую-то функциональность и например имеет данные, состояние
  - [ ] Клиенту нужна эта функциональность и данные, и он при вызове Провайдера передает ему через рендер-проп функцию с "разметкой" (это может быть не просто JSX, а JSX + какая-то логика)
  - [ ] Провайдер эту функцию вызывает, передавая в нее свои данные
  - [ ] Т.о. клиент как бы получает от провайдера данные и рендерит их в своем контексте
    - [ ] В своем контексте, потому что функция рендера создается в контексте Клиента - "чтобы ее передать, ее нужно сначала создать"
  - [ ] Клиент и Провайдер при этом являются отдельными компонентами, т.е. каждый из них - это отдельный fiber-узел
- [ ] Render Props - это старая школа кастомных хуков, когда они еще не появились

## Прочие

- IIFE в useEffect для объявления и вызова async-функций

# Хуки

- [ ] Правила использования хуков
  - [ ] Используются только на верхнем уровне компонента (т.е. не в циклах, не в условиях, не внутри других хуков, а только непосредственно в теле компонента)
- [ ] Кастомные хуки
  - [ ] Нужны чтобы инкапсулировать логику, в которой используются стандартные хуки
  - [ ] Правило именования кастомных хуков (префикс use)



# Архитектура React

- [ ] Fiber-дерево, fiber-узлы
- [ ] Цикл обновления компонента "Рендеринг > Реконсиляция > Коммит"
- [ ] Инкрементальный рендеринг



# События и их обработчики

- [ ] Навешивание обработчика на событие компонента
- [ ] Объект события
  - [ ] Всплытие события (event propagation)
  - [ ] Дефолтное поведение, предотвращение дефолтного поведения.



# Инфраструктура

## Переменные окружения

- Значение
  - При запуске приложения на локальном сервере - вычисляется на лету
  - При сборке - вычисляется и инлайнится в код
- Правила пользования
  - Не хранить чувствительные данные в SPA



# Без темы

- Отличия путей в fetch и путей до картинок
  - Откуда отсчитывается относительный и абсолютный путь
    - На локальном сервере и после деплоя
  - base
  - Корень это протокол + хост + порт. Корень и origin - это синонимы.
  - Относительный путь отсчитывается от текущей страницы
  - Абсолютный путь отсчитывается от корня



# TODO

useTransition, useDeferredValue
