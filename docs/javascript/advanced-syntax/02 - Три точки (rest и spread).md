---
title: "Оператор ... (rest и spread)"
parent: "Продвинутный синтаксис"
layout: default
---


# Оператор ...

Оператор "три точки" `...` это оператор, который движок может интерпретировать двумя способами, в зависимости от контекста, в котором оператор использован:

* `spread` - в местах, где надо *указать* значение. Например, создание массивов, объектов.
* `rest` - в местах, где надо *принять* значение. Например, параметры функций, деструктурирующее присваивание.

# ... как spread

Оператор `...` трактуется как spread в местах, где надо *указать* значение.

Например, при создании массива мы должны *указать* значения:

```javascript
const source = [5, 4, 7, 8, 3, 2];
const dest = [...source];  // <-- Тут ожидается "указание"

console.log(dest);  // [5, 4, 7, 8, 3, 2]
```

Или при создании объекта мы должны указать свойства:

```javascript
const source = {
  firstname: "Tom",
  lastname: "Sawyer"
}
const dest = { 
  ...source  // <-- Тут тоже ожидается "передача"
};

console.log(dest);  // { firstname: 'Tom', lastname: 'Sawyer' }
```

## Как запомнить

`spread` - это "распаковка", "разбиение", "раздербанивание". Как будто взять сумку с продуктами, вытащить из нее все вещи и положить их в холодильник. Причем предполагается что извлеченные вещи тут же кладутся куда-то еще, а не зависают в воздухе. Т.е. нельзя подвесить в воздухе конструкцию `...arr`, ее нужно указать в каком-то контексте, который ожидает набор значений.

## Что может

spread operator `...` позволяет:

* Разбить любой *итерируемый* объект (например, массив, map, set, строка и т.д.) на отдельные значения. P.S. Хотя строка - это примитив, но по спецификации языка она является итерируемой, поэтому spread с ней работает.
* Разбить обычный объект на отдельные свойства.

# ... как rest

Оператор `...` трактуется как rest в местах, где надо *принять* значение.

Например, описывая параметры функции, мы *принимаем* значения:

```javascript
function hello(firstname, lastname, ...rest) {
  console.log("Имя: " + firstname + " " + lastname);
  console.log("Прозвища:");
  rest.forEach(v => console.log(v));
}
// firstname, lastname |      попадут в массив rest
hello("Джеки", "Чан",    "Громобой", "Азиатский ястреб", "Ковбой", "Тайфун");

// Имя: Джеки Чан
// Прозвища:
//    Громобой
//    Азиатский ястреб
//    Ковбой
//    Тайфун
```

Или при деструктурирующем присваивании мы тоже ожидаем *принять* значение для переменной:

```javascript
let fruits = ["Яблоко", "Груша", "Апельсин", "Мандарин"];
let [apple, pear, ...other] = fruits;

other.forEach(f => console.log(f));  // Апельсин, Мандарин
```

В обоих примерах один принцип - все значения, для которых не хватило параметров \ переменных собираются в `массив` (настоящий массив, а не псевдомассив).

Аналогично для объектов - при деструктуризации мы можем извлечь поля, которые нам нужны, а остальные опять собрать, в новый объект:

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let {state, ...other} = user;  // name и age станут свойствами объекта other

console.log(state);  // Illinois
console.log(other.name);  // Huck
console.log(other.age);   // 15
```



## Как запомнить

`rest` - это "сбор остатков". Как будто вы пообещали своим детям по 5 конфет, купили большой пакет, раздали по 5 каждому, а оставшиеся конфеты высыпали в общую тарелку. Важно, что вы сделали это уже после того как всем детям достались конфеты, т.е. rest оператор всегда используется в конце списка параметров \ переменных.

# Типичные сценарии использования

## rest

### Произвольное количество параметров

Например, хотим сделать функцию сложения произвольного количества чисел:

```javascript
function sum(...numbers) {
  return numbers.reduce((acc, cur) => acc += cur, 0);
}

console.log(sum(1, 3));  // 4
console.log(sum(1, 3, 8, 14, 7, 5));  // 38
```

Для лямб аналогично:

```javascript
const sum = (...nums) => nums.reduce((prev, curr) => prev += curr, 0);
console.log(sum(5, 6, 4));  // 15
```

Или хотим принять сообщение и произвольное количество тегов для этого сообщения:

```javascript
function processMessage(message, ...tags) {
  // Что-то делаем с сообщением и тегами.
}
```

### Обертки над функциями

Например, надо сделать обертку для функции и эта обертка должна суметь принять все те же аргументы, что и оригинальная функция:

```javascript
function foobar(foo, bar) {
  const message = foo + " " + bar;
  return message;
}

function wrap(fn) {
  return function(...args) {  // <-- rest
    console.log("Какая-то добавленная функциональность.");
    return fn.apply(this, args);
  }
}

console.log(foobar("Hello", "world"));
const wrapped = wrap(foobar);
console.log(wrapped("Hello", "world"));
```

Обертка, логирующая вызовы функции и ее аргументы:

```javascript
const withLogging = (fn) => (...args) => {
  console.log(`Вызвана ${fn.name} с аргументами:`, args);
  return fn(...args);
};
```

## spread

### Скопировать массив \ объект

Можно скопировать массив, создав т.о. новый массив (копирование не глубокое, скопируется только один уровень):

```javascript
let nums = [5, 10, 3, 15];
let copy = [...nums];
```

Или скопировать объект (аналогично, копирование не глубокое):

```javascript
let tom = { firstname: "Tom", lastname: "Sawyer" };
let clone = { ...tom };
```

### Объединить массивы \ свойства объектов

Можно объединить несколько массивов \ итерируемых объектов:

```javascript
let nums = [5, 10, 3, 15];
let snums = new Set([10, 20, 15, 7]);
let merged = [...nums, ...snums];  // [5, 10, 3, 15, 10, 20, 15, 7]
```

Применяя этот оператор, мы можем представлять себе, что просто пишем отдельные элементы.

Можно объединить несколько объектов в один, слив их свойства:

```javascript
const baseInfo = {
  name: "Tom",
  age: 30
}

const extInfo = {
  city: "New York"
}

const info = { ...baseInfo, ...extInfo }

console.log(info);  // {name: 'Tom', age: 30, city: 'New York'}
```

Одинаковые свойства при этом перекрываются. Чье свойство указано последним, то и попадет в финальный объект. Это можно использовать, чтобы заменять некоторые свойства в объекте, не трогая другие и при этом получая новый объект. Полезно, когда нужна иммутабельность исходных объектов.

# Пример из React

Пример на использование в одном компоненте и оператора "остаточные параметры" и "оператора разбиения":

```react
const MyButton = ({children, ...props}) => {  // <-- rest
  return (
    <button {...props}>{children}</button>  // <-- spread
  );
};
```

В компонент MyButton передается единый объект, в котором среди прочих есть свойство children. С помощью деструктуризации мы извлекаем это свойство в отдельную переменную children, а все остальные свойства с помощью оператора "остаточные параметры" опять собираем в новый объект props.

А вот в компоненте button дальше мы уже пользуемся "оператором разбиения", который разбивает объект props на отдельные переменные и они уходят в компонент как отдельные атрибуты.

Если в компонент MyButton приходит объект props `{children: ololo, disabled: true, visible: true}`, то запись `{children, ...props}` выдерет children в отдельную переменную, а все остальное (в данном случае свойства disabled и visible) соберет в объект props. Далее, `{...props}` разобьет объект props на отдельные переменные и они уйдут в button отдельными атрибутами, все равно что написать `<button disabled=true visible=true>{children}</button>`.

