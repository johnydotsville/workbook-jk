---
title: "Объекты"
parent: JavaScript
layout: default
---



# Объекты

## Создание объекта

- Способы создания объекта
  - Объектный литерал { } - 99% случаев, когда надо просто описать объект с данными
  - Object.create() - редкие кейсы, вроде создания объекта без прототипа или с явным указанием прототипа
  - Функция конструктор (через оператор new) - обычно когда речь идет о создании экземпляра класса

## Прототип объекта

- Прототипное наследование
- Собственные и наследованные свойства
- Механизм поиска свойства (сначала у себя > потом в прототипе и далее по цепочке прототипов вверх)

## Свойства объекта

### Доступ к свойствам объекта

- Когда знаешь имя свойства - через точку .
- Когда имя свойства вычисляется (например, лежит в переменной) - через квадратные скобки [ ]

### Проверить, есть ли у объекта свойство

- Проверять только собственные свойства - метод Object.hasOwn(obj, 'foobar')
- Проверять у себя и в прототипе - оператор in, (if ('foobar' in obj))
- Устаревшие нерекомендуемые способы
  - `obj.hasOwnProperty('foobar')`
  - `if (obj.foobar !== undefined)`

### Управление свойствами

- Добавить свойство объекту
  - Просто обратиться к свойству и положить в него значение, оно создастся если его не существует.
  - Object.defineProperty() - один из нескольких методов для низкоуровневого влияния на свойства, их флаги для тонкой настройки и т.д. Нужно редко, гуглится по мере необходимости.
- Удалить свойство из объекта
  - Оператор delete, delete user.lastname или delete user["lastname"]

### Геттеры и сеттеры

- С виду выглядят как свойства (обращение без скобок()), хотя на самом деле это методы, в которых можно скрыть сложную логику установки \ получения свойства.
- Когда полезно
  - Валидация значений
  - Создание "Виртуальных" свойств - за Г\С можно скрыть логику сборки "виртуального свойства" из других свойств. Например, в объекте есть поля name и surname, можно сделать "виртуальное" свойство fullname, собрав его из name + surname.

## Обход свойств и их значений в объекте

- Части объекта можно получить как массивы и обойти:
  - Имена свойств - Object.keys(obj)
  - Значения свойств - Object.values(obj)
  - Пары "имя свойства - значение" - Object.entries(obj)
    - Массив из двух элементов [свойство, значение]
  - Не путать с этими методами у Map, Set - там они возвращают iterable-объекты.

## Методы объекта

- Методы - это обычные свойства, просто в них лежат функции.
- Как снабдить объект методом
  - Описать метод внутри объекта
  - Добавить свойство объекту и положить туда функцию
- Практические советы
  - Разделяем данные и поведение: в объектах - только поля с данными, без методов; обработка - пишем функции, которые принимают эти объекты.
  - Если нужно скомбинировать данные и поведение - используем классы.
    - P.S. Под капотом классы все равно трансформируются в объекты.

## Манипуляции с объектами

### Слияние объектов, добавление свойств объекту

- spread-оператор
- Object.assign(to, from1, from2) - не забывать, что метод мутирует "to"-объект
- Примеры
  - Слияние `const merged = { ...obj1, ...obj2 }` , `const merged = Object.assign({}, obj1, obj2)`
  - Добавление свойств объекту `{ ...obj1, { name: "John" } }` , `Object.assign(obj1, { name: "John" })`

### Клонирование объекта

- Способы создать независимую копию объекта
  - Простое одноуровневое копирование (поверхностное)
    - spread-оператор - хорош для копирования простых объектов с данными без методов, геттеров \ сеттеров. `const copy = { ...obj }`
    - Object.assign, `const copy = Object.assign({}, obj)`
  - Глубокое копирование
    - window.structuredClone(obj) - нативный способ, работает в современных браузерах.
    - Lodash.cloneDeep - сторонняя библиотека, самая распространенная.

### Сравнение объектов

- Происходит по ссылке, оператор === сравнивает не содержимое объектов, а ссылку.
- Если нужно сравнение по содержимому - делается через библиотеки (например, lodash.isEqual)